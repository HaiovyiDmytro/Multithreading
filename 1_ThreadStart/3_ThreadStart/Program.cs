/// <summary>
/// Вместе с тем потоки разделяют данные, относящиеся к тому же экземпляру объекта, что и сами потоки:
/// Так как оба потока вызывают метод Go() одного и того же экземпляра ThreadTest, они разделяют поле done.
/// Результат – 'Done', напечатанное один раз вместо двух - 1 case
/// Также возможна ситуация, когда 'Done' будет напечатано два раза вместо одного - 2 case
/// Пример демонстрирует также другое ключевое понятие – потоковую безопасность (или скорее её отсутствие).
/// Фактически результат исполнения программы не определен: возможно (хотя и маловероятно), 'Done' будет напечатано дважды.
/// Однако если мы поменяем порядок вызовов в методе Go(), шансы увидеть 'Done' напечатанным два раза повышаются радикально:
/// </summary>
internal class Program
{
    private static void Main(string[] args)
    {
        ThreadTest tt = new ThreadTest();   // Создаем общий объект
        new Thread(tt.Go).Start();          // Новый стек для потока
        tt.Go();                            // Стек основного потока
    }
}

internal class ThreadTest
{
    // Heap
    private bool done;

    /// <summary>
    /// Проблема состоит в том, что один поток может выполнить оператор if,
    /// пока другой поток выполняет WriteLine, т.е. до того как done будет установлено в true.
    /// Stack
    /// Go сейчас – экземплярный метод
    /// </summary>
    internal void Go()
    {
        if (!done)
        {
            //done = true;              // 1 case
            Console.WriteLine("Done");
            done = true;                // 2 case
        }
        for (int cycles = 0; cycles < 5; cycles++)
        {
            Console.Write(cycles.ToString());
        }
    }
}